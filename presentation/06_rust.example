use std::fmt;

struct Post {
    content: String,
    url: Option<String>,
}

impl Post {
    fn draft(content: String) -> Post {
        Post { content, url: None }
    }

    fn slug(&self) -> String {
        self.content.chars().take(5).collect()
    }
}

enum PostState {
    Scheduled(DateTime),
    Published,
}

fn validate(content: String) -> Result<Post, ErrorMsg> {
    if content.is_empty() {
        Err("content can't be empty".to_string())
    } else {
        Ok(Post::draft(content))
    }
}

fn publish_or_schedule(post: &mut Post) -> Result<PostState, ErrorMsg> {
    let url = format!("host/{}", post.slug());
    post.url = Some(url);

    if rust_magic() {
        Ok(PostState::Published)
    } else {
        Ok(PostState::Scheduled(DateTime::tomorrow()))
    }
}

fn main() -> Result<(), String> {
    let content = std::env::args().nth(1).unwrap();
    let mut post = validate(content)?;
    let state = publish_or_schedule(&mut post)?;

    let url = post.url.unwrap();
    match state {
        PostState::Scheduled(time) => println!("Scheduled: {} @ {}", url, time),
        PostState::Published => println!("Published: {}", url = url),
    };

    Ok(())
}

fn rust_magic() -> bool {
    false
}

type ErrorMsg = String;

struct DateTime {}

impl DateTime {
    fn tomorrow() -> DateTime {
        DateTime {}
    }
}

impl fmt::Display for DateTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "the time")
    }
}
